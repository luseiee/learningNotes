\documentclass{article}
% generated by Madoko, version 1.0.3
%mdk-data-line={1}


\usepackage[heading-base={2},section-num={False},bib-label={True}]{madoko2}
\usepackage{ctex}


\begin{document}



%mdk-data-line={5}
\mdxtitleblockstart{}
%mdk-data-line={5}
\mdxtitle{\mdline{5}Classic Shell Scripting Notes}%mdk
\mdxauthorstart{}
%mdk-data-line={10}
\mdxauthorname{\mdline{10}Lu, Phil}%mdk
\mdxauthorend\mdtitleauthorrunning{}{}\mdxtitleblockend%mdk

%mdk-data-line={7}
\section{\mdline{7}1.\hspace*{0.5em}\mdline{7}背景知识}\label{section}%mdk%mdk

%mdk-data-line={8}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={8}
\item\mdline{8}POSIX

%mdk-data-line={9}
\begin{quote}%mdk
\mdline{9}POSIX，Portable Operating System Interface。\mdline{9}\mdbr
\mdline{10}是UNIX系统的一个设计标准，很多类UNIX系统也在支持兼容这个标准，如Linux。\mdline{10}\mdbr
\mdline{11}遵循这个标准的好处是软件可以跨平台。所以windows也支持就很容易理解了，那么多优秀的开源软件，支持了这个这些软件就可能有windows版本，就可以完善丰富windows下的软件。
%mdk
\end{quote}%mdk%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={13}
\section{\mdline{13}2.\hspace*{0.5em}\mdline{13}入门}\label{section}%mdk%mdk

%mdk-data-line={14}
\subsection{\mdline{14}2.1.\hspace*{0.5em}\mdline{14}\#\mdline{14}!}\label{section}%mdk%mdk
\begin{mdpre}%mdk
\noindent\preindent{2}cat~\textgreater{}~nursers\\
\preindent{2}\#!~/bin/bash~-\\
\preindent{2}\\
\preindent{2}who~\textbar{}~wc~-l%mdk
\end{mdpre}\noindent\mdline{22}\mdbr
\mdline{23}之后每条命令都会用bash运行
所以，如果是py文件可以在第一行加上\mdline{24}\#\mdline{24}! /bin/python, 这样就可以使用./来运行它

%mdk-data-line={24}
\subsection{\mdline{24}2.2.\hspace*{0.5em}\mdline{24}printf}\label{sec-printf}%mdk%mdk

%mdk-data-line={25}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={25}
\item\mdline{25}printf 命令
用法与C语言非常接近%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={28}
\subsection{\mdline{28}2.3.\hspace*{0.5em}\mdline{28}重定向与管道}\label{section}%mdk%mdk

%mdk-data-line={29}
\subsubsection{\mdline{29}2.3.1.\hspace*{0.5em}\mdline{29}\textless{}\mdline{29}~\mdline{29}改变标准输入}\label{sec--}%mdk%mdk

%mdk-data-line={30}
\begin{quote}%mdk

%mdk-data-line={30}
\noindent\mdline{30}tr命令\mdline{30}\mdbr
\mdline{31}translate charactors\mdline{31} \mdline{31}%mdk
\begin{mdpre}%mdk
\noindent\preindent{2}tr~-d~'0-9'%mdk
\end{mdpre}\noindent\mdline{35}可以将标准输入中的数字全都删除
\begin{mdpre}%mdk
\noindent\preindent{2}tr~-d~'0-9'~\textless{}~mytext.txt%mdk
\end{mdpre}\noindent\mdline{39}这就改变了标准输入而是将txt文件中的内容进行修改
%mdk
\end{quote}%mdk

%mdk-data-line={41}
\subsubsection{\mdline{41}2.3.2.\hspace*{0.5em}\mdline{41}\textgreater{}\mdline{41}~\mdline{41}改变标准输出}\label{sec--}%mdk%mdk

%mdk-data-line={42}
\subsubsection{\mdline{42}2.3.3.\hspace*{0.5em}\mdline{42}\textgreater{}\mdline{42}\textgreater{}\mdline{42}~\mdline{42}输出到文件时不覆盖文件而是附加}\label{sec--}%mdk%mdk

%mdk-data-line={43}
\subsubsection{\mdline{43}2.3.4.\hspace*{0.5em}\mdline{43}\textbar{}\mdline{43}~\mdline{43}建立管道}\label{sec--}%mdk%mdk
\begin{mdpre}%mdk
\noindent\preindent{2}program1~\textbar{}~program2%mdk
\end{mdpre}\noindent\mdline{47}将program1的标准输出修改为program2的标准输入
\begin{mdpre}%mdk
\noindent\preindent{2}tr~-d~'\textbackslash{}r'~\textless{}~mytext.txt~\textbar{}~sort~\textgreater{}~mytext2.txt%mdk
\end{mdpre}\noindent\mdline{51}过程:

%mdk-data-line={53}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={53}
\item\mdline{53}tr的标准输入改成mytext.txt\mdline{53} \mdline{53}%mdk

%mdk-data-line={54}
\item\mdline{54}tr的标准输出变为sort的标准输入\mdline{54} \mdline{54}%mdk

%mdk-data-line={55}
\item\mdline{55}sort的标准输出重定向到mytext2.txt\mdline{55} \mdline{55}%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={57}
\subsubsection{\mdline{57}2.3.5.\hspace*{0.5em}\mdline{57}/dev/null和/dev/tty}\label{sec-devnulldevtty}%mdk%mdk

%mdk-data-line={58}
\noindent\mdline{58}/dev/null是一个垃圾桶，所有输出到这里的数据都会被扔掉\mdline{58} \mdline{58}%mdk
\begin{mdpre}%mdk
\noindent\preindent{4}echo~12321~\textgreater{}~/dev/null%mdk
\end{mdpre}\noindent\mdline{62}/dev/tty将重定向一个终端，键盘输入maybe，所以这个是用来作为输入的
\begin{mdpre}%mdk
\noindent\preindent{2}read~password~\textless{}~/dev/tty%mdk
\end{mdpre}\noindent\mdline{66}将会强制从/dev/tty中读取数据，一般情况下不写问题也不大貌似

%mdk-data-line={67}
\begin{quote}%mdk

%mdk-data-line={67}
\noindent\mdline{67}stty\mdline{67} \mdline{67}-echo\mdline{67}\mdbr
\mdline{68}可以将输入不显示在屏幕上\mdline{68}\mdbr
\mdline{69}stty echo\mdline{69}\mdbr
\mdline{70}重新显示\mdline{70} \mdline{70}%mdk
%mdk
\end{quote}%mdk

%mdk-data-line={72}
\subsection{\mdline{72}2.4.\hspace*{0.5em}\mdline{72}Shell脚本的参数}\label{sec-shell}%mdk%mdk

%mdk-data-line={73}
\noindent\mdline{73}\$\mdline{73}1代表第一个参数
\mdline{74}\$\mdline{74}2代表第二个参数%mdk
\begin{mdpre}%mdk
\noindent\preindent{2}cat~\textgreater{}~finduser\\
\preindent{2}\#!~/bin/sh\\
\preindent{2}\\
\preindent{2}who~\textbar{}~grep~\$1\\
\preindent{2}\textasciicircum{}D%mdk
\end{mdpre}\noindent\mdline{82}使用的时候就可以./finduser lxc

%mdk-data-line={84}
\subsection{\mdline{84}2.5.\hspace*{0.5em}\mdline{84}简单的执行跟踪}\label{section}%mdk%mdk

%mdk-data-line={85}
\noindent\mdline{85}set\mdline{85} \mdline{85}-x可以设置是否跟踪命令，跟踪命令是指每条命令执行时候在前面价一个\mdline{85} \mdline{85}+ 并显示出来%mdk

%mdk-data-line={87}
\subsection{\mdline{87}2.6.\hspace*{0.5em}\mdline{87}.profile .bashrc区别}\label{sec-profile-bashrc}%mdk%mdk

%mdk-data-line={88}
\noindent\mdline{88}.profile是每次登陆时运行\mdline{88}\mdbr
\mdline{89}.bashrc是每次运行bash时运行%mdk

%mdk-data-line={91}
\section{\mdline{91}3.\hspace*{0.5em}\mdline{91}查找与替换}\label{section}%mdk%mdk

%mdk-data-line={93}
\subsection{\mdline{93}3.1.\hspace*{0.5em}\mdline{93}正则表达式与BRE，ERE}\label{sec-breere}%mdk%mdk

%mdk-data-line={94}
\noindent\mdline{94}BRE是基本正则表达式(Basic Regular Expression)\mdline{94}\mdbr
\mdline{95}ERE是扩展正则表达式子(Extended Regular Expression)\mdline{95}\mdbr
\mdline{96}BRE是grep的默认，而程序中一般使用ERE，如python神马的，+就属于ERE的meta符号\mdline{96}\mdbr
\mdline{97}grep\mdline{97} \mdline{97}-E 表示ERE\mdline{97}\mdbr
\mdline{98}grep 则表示BRE\mdline{98} \mdline{98}%mdk

%mdk-data-line={100}
\subsection{\mdline{100}3.2.\hspace*{0.5em}\mdline{100}一些小笔记}\label{section}%mdk%mdk

%mdk-data-line={101}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={101}
\item\mdline{101}. 用来匹配任意一个字符%mdk

%mdk-data-line={102}
\item\mdline{102}+\mdline{102} 是之前的字符一个或多个 \mdline{102}\textbf{ERE}\mdline{102}%mdk

%mdk-data-line={103}
\item\mdline{103}*\mdline{103} 是之前的字符0个或多个%mdk

%mdk-data-line={104}
\item\mdline{104}？ 是之前的字符有或没有 \mdline{104}\textbf{ERE}\mdline{104}%mdk

%mdk-data-line={105}
\item\mdline{105}{}[\mdline{105}abc\mdline{105}]\mdline{105} abc中的一个%mdk

%mdk-data-line={106}
\item\mdline{106}{}[\mdline{106}a-f0-9] 16进制字符%mdk

%mdk-data-line={107}
\item\mdline{107}(abc) 连续的abc,代表一个整体，后面可以以加入\mdline{107}*\mdline{107}+之类的 \mdline{107}\textbf{ERE}\mdline{107}%mdk

%mdk-data-line={108}
\item\mdline{108}\{\mdline{108}a,b\mdline{108}\}\mdline{108} 表示前面的字符出现a,b次，或者可以不写b精确a次，有逗号表示没有上限%mdk

%mdk-data-line={109}
\item\mdline{109}一些字符集\mdline{109}[:alnum:]\mdline{109},\mdline{109} [:alpha:]\mdline{109}%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={111}
\subsection{\mdline{111}3.3.\hspace*{0.5em}\mdline{111}sed命令}\label{sec-sed}%mdk%mdk

%mdk-data-line={112}
\begin{quote}%mdk

%mdk-data-line={112}
\noindent\mdline{112}sed用来处理文本里的每一行，可以查找，替换，删除，显示等等等等，其功能完全包含grep，tr等命令\mdline{112} \mdline{112}%mdk
%mdk
\end{quote}%mdk

%mdk-data-line={114}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={114}
\item\mdline{114}它的最为常用的功能就是s:\mdline{114} \mdline{114} 
\begin{mdpre}%mdk
\noindent sed~'s/要匹配的字符/要替换成的字符/g'~file~~%mdk
\end{mdpre}%mdk

%mdk-data-line={118}
\item\mdline{118}其中/代表分界符，可以用其他符号代替；g代表搜索全文件，不写则找到第一个就结束了\mdline{118} \mdline{118}%mdk

%mdk-data-line={119}
\item\mdline{119}sed也可以接受一个脚本作为输入的一部分，把其中要执行的所有sed操作全部写入这个脚本里面\mdline{119}\mdbr
\mdline{120}举个例子: 
\begin{mdpre}%mdk
\noindent find~/home/tolstoy~-type~d~-print~\textbar{}~~~~-type~d表示类型为directory\\
sed~'s;/home/tolstoy/;/home/lt/;'~\textbar{}\\
sed~'s/\textasciicircum{}/mkdir~/'~\textbar{}~~~~~~~~~~~~~~~~~~~~插入mkdir指令\\
sh~-x~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-x表示指令追踪%mdk
\end{mdpre}%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={128}
\subsection{\mdline{128}3.4.\hspace*{0.5em}\mdline{128}cut切割字段}\label{sec-cut}%mdk%mdk

%mdk-data-line={129}
\begin{quote}%mdk

%mdk-data-line={129}
\noindent\mdline{129}cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。\mdline{129}\mdbr
\mdline{130}如果不指定 File 参数，cut 命令将读取标准输入。必须指定\mdline{130} \mdline{130}-b、-c 或\mdline{130} \mdline{130}-f 标志之一。%mdk

%mdk-data-line={132}
\mdline{132}主要参数\mdline{132}\mdbr
\mdline{133}-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了\mdline{133} \mdline{133}-n 标志。\mdline{133}\mdbr
\mdline{134}-c ：以字符为单位进行分割。\mdline{134}\mdbr
\mdline{135}-d ：自定义分隔符，默认为制表符。\mdline{135}\mdbr
\mdline{136}-f ：与-d一起使用，指定显示哪个区域。 \mdline{136}\mdbr
\mdline{137}-n ：取消分割多字节字符。仅和\mdline{137} \mdline{137}-b 标志一起使用。如果字符的最后一个字节落在由\mdline{137} \mdline{137}-b 标志的 List 参数指示的\mdline{137}\mdline{137}范围之内，该字符将被写出；否则，该字符将被排除。\mdline{137} \mdline{137}%mdk
%mdk
\end{quote}%mdk

%mdk-data-line={139}
\noindent\mdline{139}举2个例子：%mdk
\begin{mdpre}%mdk
\noindent\preindent{2}cut~-d~:~-f~1,5~/etc/passwd~~~~~该命令以:分割，取每行的第1,5列\\
\preindent{2}ls~-l~\textbar{}~cut~-c~1-10~~~~~~~~~~~~~该命令取第1\textasciitilde{}10个字符，正好是文件的读写执行权限%mdk
\end{mdpre}
%mdk-data-line={145}
\subsection{\mdline{145}3.5.\hspace*{0.5em}\mdline{145}join命令}\label{sec-join}%mdk%mdk

%mdk-data-line={146}
\begin{quote}%mdk

%mdk-data-line={146}
\noindent\mdline{146}将两个文件中，指定栏位内容相同的行连接起来。%mdk
%mdk
\end{quote}%mdk

%mdk-data-line={148}
\subsection{\mdline{148}3.6.\hspace*{0.5em}\mdline{148}awk}\label{sec-awk}%mdk%mdk

%mdk-data-line={149}
\begin{quote}%mdk

%mdk-data-line={149}
\noindent\mdline{149}awk是一种“单命令行程序”\mdline{149}\mdbr
\mdline{150}它的使用模式为:%mdk
\begin{mdpre}%mdk
\noindent\preindent{2}awk~'program'~{}[~file~]%mdk
\end{mdpre}\noindent\mdline{154}和sed命令很像\mdline{154}\mdbr
\mdline{155}其中program的基本格式为 pattern \mdline{155}\{\mdline{155} action \}
%mdk
\end{quote}%mdk

%mdk-data-line={157}
\noindent\mdline{157}举个例子：%mdk
\begin{mdpre}%mdk
\noindent\preindent{2}awk~-F~:~'\{print~\$1,~\$5~\}'~/etc/passwd~~~~以:作为分隔符，输出第一字段第五字段%mdk
\end{mdpre}%mdk


\end{document}
