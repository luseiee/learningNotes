Package : ctex
Title         : Classic Shell Scripting Notes
Author        : Lu, Phil

[TITLE]

# 背景知识
- POSIX
> POSIX，Portable Operating System Interface。  
是UNIX系统的一个设计标准，很多类UNIX系统也在支持兼容这个标准，如Linux。  
遵循这个标准的好处是软件可以跨平台。所以windows也支持就很容易理解了，那么多优秀的开源软件，支持了这个这些软件就可能有windows版本，就可以完善丰富windows下的软件。

# 入门
## #! 
``` 
  cat > nursers
  #! /bin/bash -
  
  who | wc -l
```
  
之后每条命令都会用bash运行
所以，如果是py文件可以在第一行加上#! /bin/python, 这样就可以使用./来运行它

## grep命令
`
-v 反向选取，输出选不满足条件的
`

## printf
- printf 命令
用法与C语言非常接近

## 重定向与管道
### <\ 改变标准输入
> tr命令  
translate charactors  
```
  tr -d '0-9'
```
可以将标准输入中的数字全都删除
```
  tr -d '0-9' < mytext.txt
```
这就改变了标准输入而是将txt文件中的内容进行修改

### \>\ 改变标准输出
### \>\>\ 输出到文件时不覆盖文件而是附加
### |\ 建立管道
```
  program1 | program2
```
将program1的标准输出修改为program2的标准输入
```
  tr -d '\r' < mytext.txt | sort > mytext2.txt
```
过程:

1. tr的标准输入改成mytext.txt  
2. tr的标准输出变为sort的标准输入  
3. sort的标准输出重定向到mytext2.txt  

### /dev/null和/dev/tty
/dev/null是一个垃圾桶，所有输出到这里的数据都会被扔掉  
```
    echo 12321 > /dev/null
```
/dev/tty将重定向一个终端，键盘输入maybe，所以这个是用来作为输入的
```
  read password < /dev/tty
```
将会强制从/dev/tty中读取数据，一般情况下不写问题也不大貌似
> stty -echo  
可以将输入不显示在屏幕上  
stty echo  
重新显示  

## Shell脚本的参数
\$1代表第一个参数
\$2代表第二个参数
```
  cat > finduser
  #! /bin/sh
  
  who | grep $1
  ^D
```
使用的时候就可以./finduser lxc

## 简单的执行跟踪
set -x可以设置是否跟踪命令，跟踪命令是指每条命令执行时候在前面价一个 + 并显示出来

## .profile .bashrc区别
.profile是每次登陆时运行  
.bashrc是每次运行bash时运行

# 查找与替换

## 正则表达式与BRE，ERE

BRE是基本正则表达式(Basic Regular Expression)  
ERE是扩展正则表达式子(Extended Regular Expression)  
BRE是grep的默认，而程序中一般使用ERE，如python神马的，+就属于ERE的meta符号  
grep -E 表示ERE  
grep 则表示BRE  

## 一些小笔记

- . 用来匹配任意一个字符
- \+ 是之前的字符一个或多个 **ERE**
- \* 是之前的字符0个或多个
- ？ 是之前的字符有或没有 **ERE**
- \[abc\] abc中的一个
- \[a-f0-9] 16进制字符
- (abc) 连续的abc,代表一个整体，后面可以以加入\*+之类的 **ERE**
- \{a,b\} 表示前面的字符出现a,b次，或者可以不写b精确a次，有逗号表示没有上限
- 一些字符集[:alnum:], [:alpha:]

## sed命令
> sed用来处理文本里的每一行，可以查找，替换，删除，显示等等等等，其功能完全包含grep，tr等命令  

- 它的最为常用的功能就是s:  
```
  sed 's/要匹配的字符/要替换成的字符/g' file  
```
- 其中/代表分界符，可以用其他符号代替；g代表搜索全文件，不写则找到第一个就结束了  
- sed也可以接受一个脚本作为输入的一部分，把其中要执行的所有sed操作全部写入这个脚本里面  
举个例子: 
```
  find /home/tolstoy -type d -print |    -type d表示类型为directory
  sed 's;/home/tolstoy/;/home/lt/;' |
  sed 's/^/mkdir /' |                    插入mkdir指令
  sh -x                                  -x表示指令追踪
```

## cut命令

> cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。  
如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。

> 主要参数  
-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。  
-c ：以字符为单位进行分割。  
-d ：自定义分隔符，默认为制表符。  
-f ：与-d一起使用，指定显示哪个区域。   
-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br />范围之内，该字符将被写出；否则，该字符将被排除。  

举2个例子：
```
  cut -d : -f 1,5 /etc/passwd     该命令以:分割，取每行的第1,5列
  ls -l | cut -c 1-10             该命令取第1~10个字符，正好是文件的读写执行权限
```

## join命令
> 将两个文件中，指定栏位内容相同的行连接起来。 

## awk命令
> awk是一种“单命令行程序”  
> 它的使用模式为:
```
  awk 'program' [ file ]
```
> 和sed命令很像  
> 其中program的基本格式为 pattern \{ action }

举个例子：
```
  awk -F : '{print $1, $5 }' /etc/passwd    以:作为分隔符，输出第一字段第五字段
```

# 文本处理工具

## sort命令
`
-r 反转
-n 以数值排序，比如10就要排在2的后面
-k 选择按第几个字段排序，当有多个-k的时候就优先左边再右边
-k 1.2,2.3 从第一个字段的第二个字符比较到第二个字段的第三个字符
-t 选择字段的分隔符，默认以空白分隔
-f 忽略大小写
-u 去重
`
举几个例子:
```
  sort -t: -k4n -k3n /etc/passwd 以:作为分隔符，先按照第四字段数值排序再按第三字段数值排序
```

## uniq命令
> sort中的-u选项虽然会删除重复，但是它知识按照键值进行排序而不是按照整行内容，因此我们需要uniq命令

`
uniq -c 在输出上加上计数
`

举个例子：
```
  sort a.txt | uniq
```

## fmt命令

常常用在管道中，用来重新格式化段落，嘴馋工的功能就是规定输出宽度

```
  cat a.txt | fmt -w 50
```

## wc命令

输出行数，字数，字节数

```
  cat a.txt | wc
  输出: 18 155 960
  -c 字节数
  -l 行数
  -w 字数
```

## head命令, tail命令

```
  head -n8 显示前八行
  tail -n9 显示后九行
  tail -f -n2 监视最后两行，这时tail命令永远不会结束
```

## file命令

file将参数文件内容的前几个字节与样式数据库进行比对，再输出一份简短报告
```
  file a.txt
  输出: a.txt: ASCII text
```